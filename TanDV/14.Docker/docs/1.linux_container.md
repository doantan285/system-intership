# Tổng quan về Linux Container (LXC)

## I. Linux Container là gì?

### 1. Định nghĩa

**Linux Containers (LXC)** là một công nghệ ảo hóa ở **cấp hệ điều hành (OS-level virtualization)**. Containers cho phép chạy nhiều **môi trường cô lập (isolated environments)** trên cùng một **nhân Linux (Linux kernel)**, mà không cần khởi động thêm hệ điều hành riêng như khi dùng máy ảo (VM).

Thay vì ảo hóa toàn bộ phần cứng như Máy ảo (Virtual Machine - VM), Container hóa hoạt động ở cấp ứng dụng, tạo ra các môi trường biệt lập (container) chứa mọi thứ một ứng dụng cần để chạy (mã, runtime, thư viện, công cụ hệ thống, và cài đặt).

Mỗi container giống như một "máy tính nhỏ":

- Có **file system riêng**.
- Có **process riêng**.
- Có **network interface riêng**.
- Nhưng dùng chung **kernel** của hệ điều hành host.

> Nói cách khác: Containers chia sẻ kernel nhưng cô lập không gian người dùng (user space).

### 2. Cách container hoạt động (công nghệ nền tảng)

Linux Containers dựa vào hai công nghệ lõi của Linux kernel:

**a. Namespaces:**

- Namespaces cung cấp sự cô lập (isolation) cho các tài nguyên hệ thống.
- Mỗi container có thể thấy và dùng tài nguyên riêng của nó.
- Các loại namespaces phổ biến:
  - `pid:` Cô lập các tiến trình (processes) trong container.
  - `net:` Cô lập network interfaces, IP, routing table
  - `mnt (Mount):` Cô lập hệ thống file, cho phép mỗi container có hệ thống file riêng.
  - `uts:` Cô lập hostname và domain name.
  - `ipc:` Cô lập cơ chế giao tiếp liên tiến trình (Inter-Process Communication).
  - `user:` Cô lập các user và nhóm người dùng.

**b. Control Groups (cgroups):** kiểm soát việc sử dụng tài nguyên (CPU, RAM, I/O, network...) của mỗi container. Nó giúp:

- Giới hạn container dùng tối đa bao nhiêu CPU, RAM,...
- Theo dõi mức tiêu thụ tài nguyên
- Ngăn container chiếm dụng toàn bộ hệ thống

### 3. Khác nhau giữa Container và Máy ảo (VM)

| Tiêu chí | Container   | Virtual Machine   |
| --------- | ------------- | -------------- |
| **Mức độ ảo hóa** | Ảo hóa ở cấp hệ điều hành (chia sẻ kernel) | Ảo hóa ở cấp phần cứng (mỗi VM có OS riêng) |
| **Tài nguyên**  | Nhẹ, dùng chung kernel  | Nặng, cần bộ nhớ và CPU riêng |
| **Thời gian khởi động** | Rất nhanh (vài giây) | Chậm hơn (vài chục giây hoặc phút)  |
| **Khả năng di chuyển**  | Dễ dàng, chỉ cần container image  | Khó hơn, cần di chuyển cả máy ảo  |
| **Tính bảo mật** | Tốt, nhưng chia sẻ kernel nên phụ thuộc vào kernel security | Mạnh mẽ hơn do cách ly hoàn toàn  |
| **Ứng dụng điển hình**  | Microservices, CI/CD, DevOps, Cloud Native | Chạy nhiều OS khác nhau, legacy apps  |

## II. Các thành phần chính của Linux Container

```diff
+-------------------------------------+
|  Management (Docker / LXD / CRI-O)  |
+-------------------------------------+
|  Container Runtime (runc, containerd)|
+-------------------------------------+
|  Namespaces + Cgroups + UnionFS     |
+-------------------------------------+
|  Linux Kernel                       |
+-------------------------------------+
|  Hardware (CPU, RAM, Disk, NIC)     |
+-------------------------------------+
```

### 1. Namespaces

- **Namespaces** là công nghệ cô lập (**isolation**) trong **Linux Kernel**.
- Chúng đảm bảo rằng tiến trình trong container chỉ nhìn thấy tài nguyên của riêng nó (PID, network, filesystem, user...).

Các loại namespaces phổ biến:

| Namespace | Ký hiệu | Mô tả |
| --------- | ------- | ----- |
| **PID**       | pid     | Cô lập tiến trình. Mỗi container có PID riêng (PID 1 bên trong container khác PID host). |
| **Network**   | net     | Mỗi container có network interface, IP, route table, DNS riêng. |
| **Mount**     | mnt     | Cô lập hệ thống file, mount points riêng. |
| **UTS**       | uts     | Cô lập hostname và domain name |
| **IPC**       | ipc     | Cô lập cơ chế giao tiếp liên tiến trình |
| **User**      | user    | Cô lập UID/GID giữa host và container (user trong container không cần quyền root thật). |

> Namespaces tạo ảo giác “một máy riêng biệt”, trong khi thật ra chỉ là tiến trình Linux bình thường.

### 2. Control Groups (cgroups)

**Cgroups** giúp giới hạn, theo dõi và phân bổ tài nguyên mà container được phép dùng:

- **CPU**
- **RAM**
- **I/O**
- **Network**
- **GPU** (nếu có)

Ví dụ:

- Giới hạn container dùng tối đa 1 CPU và 512 MB RAM.
- Ngăn container chiếm toàn bộ tài nguyên hệ thống.

> Cgroups đảm bảo container không ảnh hưởng lẫn nhau hoặc đến host.

### 3. Union File System (Filesystem Layering)

Container không có hệ thống file riêng biệt như máy ảo - mà dùng **union filesystem**, giúp chia sẻ và tái sử dụng lớp dữ liệu (layer).

Các filesystem phổ biến:

- **OverlayFS**
- **AUFS**
- **btrfs**
- **ZFS**

> Điều này giúp container khởi động nhanh và tiết kiệm dung lượng.

### 4. Container Image

Image là bản đóng gói của ứng dụng + môi trường cần thiết. Nó chứa:

- Hệ thống file gốc (root filesystem)
- Thư viện, binary, config của app
- Metadata (CMD, ENV, ENTRYPOINT...)

> Khi chạy `docker run`, Docker lấy image này, tạo container từ nó.

### 5. Container Runtime

Container runtime là thành phần chịu trách nhiệm thực thi container.

Có hai cấp độ runtime:

| Loại | Ví dụ | Vai trò |
| ------ | -------- | ------------- |
| **High-level runtime** | Docker Engine, LXD, containerd, CRI-O | Quản lý vòng đời container (tạo, xóa, network, volume, API) |
| **Low-level runtime**  | runc | Giao tiếp trực tiếp với kernel để khởi tạo namespaces, cgroups... |

> `runc` tuân theo chuẩn **OCI (Open Container Initiative)** — giúp các nền tảng container khác nhau tương thích với nhau.

### 6. Networking

Container có network stack riêng thông qua namespace `net`.

Docker và LXC tạo virtual network interfaces (veth pairs) để container có IP riêng và kết nối ra ngoài qua NAT hoặc bridge.

Các mô hình phổ biến:

- **bridge (mặc định)** - container kết nối qua `docker0`.
- **host** - container chia sẻ network với host.
- **overlay** - kết nối nhiều host trong cluster (Kubernetes dùng nhiều).

### 7. Management Layer

Là lớp quản lý và điều phối containers, cung cấp API, CLI và orchestration.

Ví dụ:

- **LXD** → quản lý LXC containers.
- **Docker Daemon** → quản lý Docker containers.
- **Kubernetes / Podman / OpenShift** → orchestration nhiều containers.

> Lớp này giúp người dùng tạo, quản lý, giám sát và tự động hoá containers dễ dàng hơn.

## III. Cách hoạt động của Linux Container

Khi bạn chạy một container:

```txt
1. Hệ thống tạo ra một process mới.
2. Process này được đặt trong các namespaces riêng → cô lập.
3. Áp dụng cgroups → giới hạn tài nguyên.
4. Gắn filesystem riêng (image + overlay).
5. Thiết lập network riêng.
6. Conainer chạy, như một “máy mini Linux” dùng chung kernel host.
```

### 1. Tạo Container process

Khi chạy lệnh như `docker run` hoặc `lxc-start`:

```bash
lxc-start -n mycontainer
# hoặc
docker run -it ubuntu bash
```

Hệ thống sẽ tạo ra một process con (child process), nhưng process này:

- Được đặt trong các namespaces riêng (PID, net, mnt, uts, ipc, user, v.v.).
- Bị giới hạn tài nguyên bởi cgroups.
- Có root filesystem riêng biệt.

> Dù chỉ là một process, nó “nhìn thấy” như thể nó đang chạy trên một máy Linux độc lập.

### 2. Cô lập tài nguyên bằng Namespaces

Namespaces là cơ chế tạo ra ảo giác rằng container có:

- PID riêng.
- Network interface riêng.
- File system riêng.
- Hostname riêng.
- User riêng (không ảnh hưởng tới host).

Ví dụ:

- Container có process PID 1 (init của nó), nhưng trên host có thể là PID 2245.
- Mỗi container có IP riêng (vd: `172.17.0.2`) tách biệt khỏi host.

> Nhờ đó, container không thể thấy hay can thiệp vào tiến trình, file hay mạng của host.

### 3. Giới hạn tài nguyên bằng Cgroups

`cgroups` (control groups) kiểm soát:

- CPU quota / shares
- Bộ nhớ RAM tối đa
- Disk I/O
- Network bandwidth

Ví dụ:

```bash
# Giới hạn container chỉ dùng 1 CPU và 512MB RAM
lxc-cgroup -n mycontainer limits.cpu=1
lxc-cgroup -n mycontainer limits.memory=512M
```

> Điều này ngăn việc một container “chiếm trọn” tài nguyên của host.

### 4. Cung cấp Filesystem riêng (UnionFS / OverlayFS)

Container không dùng filesystem của host, mà có root filesystem riêng biệt, thường dựa trên image (Ubuntu, Alpine,...).

- Các lớp (layers) chỉ đọc được chia sẻ (read-only) giữa nhiều container.
- Một lớp ghi tạm (read-write) được tạo riêng cho container đó.

> Điều này giúp container nhẹ, khởi động nhanh, tái sử dụng tốt.

### 5. Thiết lập Network riêng

Container dùng network namespace riêng, nghĩa là:

- Có IP, MAC, routing table riêng.
- Giao tiếp với thế giới ngoài qua bridge interface (docker0, lxcbr0, v.v.).

Ví dụ:

```nginx
Host IP: 192.168.1.10
Container IP: 172.17.0.2
```

> Nhờ đó, container hoạt động độc lập trong mạng ảo của mình.

### 6. Quản lý bằng Runtime và Daemon

Tầng trên cùng là các công cụ giúp bạn quản lý container dễ dàng:

- **LXC / LXD** → native Linux containers
- **Docker Engine + containerd + runc** → hệ sinh thái phổ biến
- **Podman / CRI-O / Kubernetes** → orchestration, quản lý nhiều container

Các công cụ này đảm nhận việc:

- Tạo namespaces & cgroups
- Mount filesystem
- Cấu hình mạng
- Giám sát và xoá container khi dừng
